package org.aksw.limes.core.evaluation.evaluator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.aksw.limes.core.datastrutures.EvaluationRun;
import org.aksw.limes.core.datastrutures.GoldStandard;
import org.aksw.limes.core.datastrutures.TaskAlgorithm;
import org.aksw.limes.core.datastrutures.TaskData;
import org.aksw.limes.core.evaluation.qualititativeMeasures.QualitativeMeasuresEvaluator;
import org.aksw.limes.core.evaluation.quantitativeMeasures.IQuantitativeMeasure;
import org.aksw.limes.core.exceptions.UnsupportedMLImplementationException;
import org.aksw.limes.core.io.cache.ACache;
import org.aksw.limes.core.io.cache.Instance;
import org.aksw.limes.core.io.cache.MemoryCache;
import org.aksw.limes.core.io.mapping.AMapping;
import org.aksw.limes.core.io.mapping.MappingFactory;
import org.aksw.limes.core.ml.algorithm.AMLAlgorithm;
import org.aksw.limes.core.ml.algorithm.ActiveMLAlgorithm;
import org.aksw.limes.core.ml.algorithm.MLImplementationType;
import org.aksw.limes.core.ml.algorithm.MLResults;
import org.aksw.limes.core.ml.algorithm.SupervisedMLAlgorithm;
import org.aksw.limes.core.ml.algorithm.UnsupervisedMLAlgorithm;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This evaluator is responsible for evaluating set of datasets that have source, target, gold standard and mappings against set of measures
 *
 * @author Mofeed Hassan (mounir@informatik.uni-leipzig.de)
 * @version 1.0
 * @since 1.0
 */
public class Evaluator {
    static Logger logger = LoggerFactory.getLogger(Evaluator.class);

    List<EvaluationRun> runsList = new ArrayList<EvaluationRun>();

    /**  The qualitative measure evaluator that evaluates the predictions generated by a machine learning algorithm using a gold standard and set of measures*/
    private QualitativeMeasuresEvaluator eval = new QualitativeMeasuresEvaluator();

    //remember
    //---------AMLAlgorithm(concrete:SupervisedMLAlgorithm,ActiveMLAlgorithm or UnsupervisedMLAlgorithm--------
    //---                                                                                              --------
    //---         ACoreMLAlgorithm (concrete: EAGLE,WOMBAT,LION) u can retrieve it by get()            --------
    //---                                                                                              --------
    //---------------------------------------------------------------------------------------------------------

    /**
     * @param TaskAlgorithms  the set of algorithms used to generate the predicted mappings
     * @param datasets    the set of the datasets to apply the algorithms on them. The should include source Cache, target Cache, goldstandard and predicted mapping
     * @param QlMeasures  the set of qualitative measures
     * @param QnMeasures  the set of quantitative measures
     * @return List -  contains list of multiple runs evaluation results corresponding to the algorithms, its implementation and used dataset
     */
    public List<EvaluationRun> evaluate(List<TaskAlgorithm> TaskAlgorithms, Set<TaskData> datasets ,Set<EvaluatorType> QlMeasures, Set<IQuantitativeMeasure> QnMeasures) {
        AMapping predictions = null;
        Map<EvaluatorType, Double> evaluationResults = null;
        try{
            for (TaskAlgorithm tAlgorithm : TaskAlgorithms) {     //iterate over algorithms tasks(type,algorithm,parameter)
                logger.info("Running algorihm: "+tAlgorithm.getMlAlgorithm().getName());
                for (TaskData dataset : datasets) {     //iterate over datasets(name,source,target,mapping,training,pseudofm)
                    logger.info("Used dataset: "+dataset.dataName);
                    //initialize the algorithm with source and target data, passing its parameters too ( if it is null in case of WOMBAT it will use its defaults)
                    tAlgorithm.getMlAlgorithm().init(null, dataset.source, dataset.target);
                    
                    MLResults mlModel= null; // model resulting from the learning process
                    
                    if(tAlgorithm.getMlType().equals(MLImplementationType.SUPERVISED_BATCH))
                    {
                        logger.info("Implementation type: "+MLImplementationType.SUPERVISED_BATCH);
                        SupervisedMLAlgorithm sml =(SupervisedMLAlgorithm)tAlgorithm.getMlAlgorithm();
                        mlModel = sml.learn(dataset.training);
                    }
                    else if(tAlgorithm.getMlType().equals(MLImplementationType.SUPERVISED_ACTIVE))
                    {
                        logger.info("Implementation type: "+MLImplementationType.SUPERVISED_ACTIVE);
                        ActiveMLAlgorithm sml =(ActiveMLAlgorithm)tAlgorithm.getMlAlgorithm();
                        sml.getMl().setConfiguration(dataset.evalData.getConfigReader().getConfiguration());
//                        if(tAlgorithm.getMlAlgorithm().getName().equals("Decision Tree Learning")){
//                            ((DecisionTreeLearning)sml.getMl()).setPropertyMapping(dataset.evalData.getPropertyMapping());
//                            ((DecisionTreeLearning)sml.getMl()).setInitialMapping(dataset.training);
//                        }
                        sml.activeLearn();
                        //mlModel = sml.activeLearn(dataset.training);
                        AMapping nextExamples = sml.getNextExamples((int)Math.round(0.5*dataset.training.size()));
                        AMapping oracleFeedback = oracleFeedback(nextExamples,dataset.training);
                        mlModel = sml.activeLearn(oracleFeedback);
                     }
                    else if(tAlgorithm.getMlType().equals(MLImplementationType.UNSUPERVISED))
                    {
                        logger.info("Implementation type: "+MLImplementationType.UNSUPERVISED);
                        UnsupervisedMLAlgorithm sml =(UnsupervisedMLAlgorithm)tAlgorithm.getMlAlgorithm();
                        mlModel = sml.learn(dataset.pseudoFMeasure);
                    }
                    predictions = tAlgorithm.getMlAlgorithm().predict(dataset.source, dataset.target, mlModel);
                    logger.info("Start the evaluation of the results");
                    evaluationResults = eval.evaluate(predictions, dataset.goldStandard, QlMeasures);
                    EvaluationRun er = new EvaluationRun(tAlgorithm.getMlAlgorithm().getName().replaceAll("\\s+", ""),tAlgorithm.getMlType().name().replaceAll("//s", ""),dataset.dataName.replaceAll("//s", ""),evaluationResults);
                    runsList.add(er);
                }
            }
        }
        catch (UnsupportedMLImplementationException e) {
            e.printStackTrace();
        }
        return runsList;

    }


    /**
     * @param algorithm  the algorithm used to generate the predicted mappings
     * @param datasets    the set of the datasets to apply the algorithms on them. The should include source Cache, target Cache, goldstandard and predicted mapping
     * @param folds the number of subsamples to divide the data (k)
     * @param qlMeasures  the set of qualitative measures
     * @param qnMeasures  the set of quantitative measures
     * @return List -  contains list of multiple runs evaluation results corresponding to the algorithms, its implementation and used dataset
     * 
     * @author Tommaso Soru (tsoru@informatik.uni-leipzig.de)
     * @version 2016-02-26
     */
    /*Table<String, String, Map<EvaluatorType, Double>>*/
    public List<EvaluationRun>  crossValidate(AMLAlgorithm algorithm, Set<TaskData> datasets,
            int folds, Set<EvaluatorType> qlMeasures, Set<IQuantitativeMeasure> qnMeasures) {

        //      Table<String, String, Map<EvaluatorType, Double>> evalTable = HashBasedTable.create();// multimap stores aglortihmName:datasetname:List of evaluations

        // select a dataset-pair to evaluate each ML algorithm on
        for (TaskData dataset : datasets) {

            ACache source = dataset.source;
            ArrayList<Instance> srcInstances = source.getAllInstances();
            AMapping mapping = dataset.mapping;
            AMapping goldstd = dataset.goldStandard.referenceMappings;

            // create source partitions: S into S1, .., Sk
            ACache[] srcParts = new ACache[folds];
            // create source folds (opposite of partitions)
            ACache[] srcFolds = new ACache[folds];
            // create mappings
            AMapping[] srcMap = new AMapping[folds];
            AMapping[] srcGold = new AMapping[folds];
            for (int i = 0; i < folds; i++) {
                srcParts[i] = new MemoryCache();
                srcFolds[i] = new MemoryCache();
                // AN: Changed the type of mapping as the input is a type, not the name
                // srcMap[i] = MappingFactory.createMapping(dataset.pairName + "_mapping_" + i);
                //srcGold[i] = MappingFactory.createMapping(dataset.pairName + "_goldstd_" + i);
                srcMap[i] = MappingFactory.createDefaultMapping();
                srcGold[i] = MappingFactory.createDefaultMapping();
            }

            // randomly distribute instances into #folds partitions
            for (Instance inst : srcInstances) {
                int destination;
                do {
                    destination = (int) (Math.random() * folds);
                } while (srcParts[destination].size() > source.size() / folds);
                srcParts[destination].addInstance(inst);

                // build folds
                for (int i = 0; i < folds; i++)
                    if (i != destination)
                        srcFolds[i].addInstance(inst);
            }

            // copy mapping entries into the one of the respective fold
            HashMap<String, HashMap<String, Double>> map = mapping.getMap();
            for (int i = 0; i < folds; i++) {
                for (Instance inst : srcParts[i].getAllInstances()) {
                    String uri = inst.getUri();
                    // look for (s, t) belonging to mapping and create G1, ..., G10
                    if (map.containsKey(uri))
                        srcMap[i].add(uri, map.get(uri));
                }
            }

            // copy gold standard entries into the one of the respective fold
            HashMap<String, HashMap<String, Double>> gst = goldstd.getMap();
            for (int i = 0; i < folds; i++) {
                for (Instance inst : srcParts[i].getAllInstances()) {
                    String uri = inst.getUri();
                    // look for (s, t) belonging to gold standard and create G1, ..., G10
                    if (gst.containsKey(uri))
                        srcGold[i].add(uri, gst.get(uri));
                }
            }

            //////////////
            GoldStandard goldStandard = new GoldStandard(null, dataset.source.getAllUris(), dataset.target.getAllUris());

            // train and test folds
            for (int i = 0; i < folds; i++) {

                // algorithm .setSourceCache(srcFolds[i]); 
                algorithm.init(null, srcFolds[i], null);
                // target cache is invariant
                MLResults model =null;
                //algorithm.learn(srcMap[i]);

                try {
                    if(algorithm instanceof SupervisedMLAlgorithm)
                        model = algorithm.asSupervised().learn(srcMap[i]);
                    else if(algorithm instanceof ActiveMLAlgorithm)
                        model = algorithm.asActive().activeLearn(srcMap[i]);
                } catch (UnsupportedMLImplementationException e) {
                    e.printStackTrace();
                }


                goldStandard.referenceMappings = srcGold[i];
                EvaluationRun er = new EvaluationRun(algorithm.getName() + " - fold " + i,dataset.dataName, eval.evaluate(algorithm.predict(srcFolds[i], srcFolds[i], model), goldStandard, qlMeasures));
                runsList.add(er);
                //               evalTable.put(algorithm.getName() + " - fold " + i, dataset.dataName, eval.evaluate(algorithm.predict(srcFolds[i], srcFolds[i], model), goldStandard, qlMeasures));
            }
        }
        return runsList;
        //        return evalTable;

    }

    /**
     * It provides the feedback of the oracle by comparing the prediction to the reference mapping.It is used by evaluator in the Supervised_Active.
     * @param predictionMapping The predictions created by a machine learning
     * @param referenceMapping The gold standard to evaluate the prediction
     * @return Mapping - The mappings from the predictions that exist in the gold standard
     */
    private AMapping oracleFeedback(AMapping predictionMapping, AMapping referenceMapping) {
        AMapping result = MappingFactory.createDefaultMapping();

        for(String s : predictionMapping.getMap().keySet()){
            for(String t : predictionMapping.getMap().get(s).keySet()){
                if(referenceMapping.contains(s, t)){
//                    result.add(s, t, predictionMapping.getMap().get(s).get(t));
                    result.add(s, t, 1.0);
                }else{
                    result.add(s, t, 0.0);
                }
            }
        }
        return result;
    }
    /*
     * It displays the overall results of evaluating machine learning algorithm regarding qualitative measures
     * @param results The evaluation results algorith:datast:evaluation_measure:score
     */
/*    public static void dsiplayOverallResults(Table<String, String, Map<EvaluatorType, Double>> results)
    {
        for (String mlAlgorithm : results.rowKeySet()) {
            for (String dataset : results.columnKeySet()) {
                for (EvaluatorType measure : results.get(mlAlgorithm, dataset).keySet()) {
                    System.out.println(mlAlgorithm+"\t"+dataset+"\t"+measure+"\t"+results.get(mlAlgorithm, dataset).get(measure));
                }
            }
        }
    }*/

    /*
     * It displays the results of evaluating a machine learning algorithm regarding qualitative measures
     * @param results The evaluation evaluation_measure:score
     */
/*    public static void dsiplayResults(Map<EvaluatorType, Double> results)
    {
        for (EvaluatorType measure : results.keySet()) {
            System.out.println(measure+"\t"+results.get(measure));
        }

    }*/


}
